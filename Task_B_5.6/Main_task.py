# ЗАДАНИЕ:
# Создать игру крестики-нолики.
# Консоль, куда будет выводиться ход игры. С помощью форматированных строк.
# ------------------------------------------------------------------------

# БЛОК 0. ВВОДНЫЕ ПЕРЕМЕННЫЕ:
main_board = [ # Основное поле игры, заданное условиями задачи.
     ['-', '-', '-'],
     ['-', '-', '-'],
     ['-', '-', '-']
]
start_game_board = main_board.copy() # Стартовое поле игры. Созадем через копию основного
# поля игры, чтобы исходное поле игры случайно не испортить.
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# >>>>> БЛОК 1. (начало). Печатаем сообщение о начале игры и печатаем стартовое поле игры
print('Начинается игра!')

def current_gboard(list_): # Функций показывает вид текущего поля игры.
    print('Текущий вид поля игры:')
    cur_game_board = []
    for i in start_game_board:
        cur_game_board.append(i)
        print(i)
    return cur_game_board

gb = current_gboard(start_game_board) # Создаю переменную текущего game board,
# через функцию current_gboard(start_game_board). В последствии переменная gb будет меняться,
# через контролер ввода символов игроков.
print('---------------------------------------')
# <<<<< БЛОК 1. (конец).

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# >>>>> БЛОК ПРОВКЕРОК. Проверки выигрыша игроков.
# >>>>> ПРОВЕРКА 1 (начало) - проверка совпадения всех символов по строке прямо.
def func_win_line(list_):
    counter_simbol_x = 0
    counter_simbol_o = 0
    simbol_x, simbol_o = 'х', 'о'
    for row in list_: # Проходим по строкам
        for element_to_check in row: # Проходим по символам в строке
            if element_to_check == simbol_x: # если символ игрока 1 попадается,
                counter_simbol_x += 1 # то добавляем его в счетчик "x"
                if counter_simbol_x == counter_column: # если кол-во символов
                    # в счетчике 'х' равно кол-ву столбцов, то условие победы выполнено.
                    print('---------------------------------------')
                    print('Победил Игрок 1. Символы совпали по строке.')
                    return True # - нужно для условия для цикла While (см. БЛОК 4. КОНТРОЛЕР).
            else:
                if element_to_check == simbol_o: # если символ игрока 2 попадается,
                    counter_simbol_o += 1 # то добавляем его в счетчик "o"

                    if counter_simbol_o == counter_column:
                        print('---------------------------------------')
                        print('Победил Игрок 2. Символы совпали по строке.')
                        return True # - нужно для условия для цикла While (см. БЛОК 4. КОНТРОЛЕР).

        counter_simbol_x = 0 # Если в строке не совпали все символы "x", обнуляем счетчик "x".
        counter_simbol_o = 0 # Если в строке не совпали все символы "о", обнуляем счетчик "о".

# <<<<< ПРОВЕРКА 1 (конец). ГОТОВО.
# --------------------------------------------------------------------------

# >>>>> ПРОВЕРКА 2 (начало) - проверка совпадения всех символов по диагонали массива.
def func_win_diog(list_):
    counter_simbol_x = 0
    counter_simbol_o = 0
    simbol_x, simbol_o = 'х', 'о'
    step = 0 #Шаг смещения по следующей строке - будет меняться при итерации цикла For ниже.
    for row in list_:
        element_to_check = list_[step][step] # переход по диагонали матрицы (в каждой следующей строке
        # сдвигаемся на один символ правее).
        if element_to_check == simbol_x:
            counter_simbol_x += 1
        if counter_simbol_x == counter_row:
            print('---------------------------------------')
            print('Победил Игрок 1')
            return True # - нужно для условия для цикла While (см. БЛОК 4. КОНТРОЛЕР).
        else:
            if element_to_check == simbol_o:
                counter_simbol_o += 1

            if counter_simbol_o == counter_row:
                print('---------------------------------------')
                print('Победил Игрок 2.')
                return True # - нужно для условия для цикла While (см. БЛОК 4. КОНТРОЛЕР).
        step += 1 # шаг задает смещение на 1 сроку и 1 столбец каждую поледующую итерацию.
# <<<<< ПРОВЕРКА 2 (конец). ГОТОВО!
# --------------------------------------------------------------------------

# >>>>> ПРОВЕРКА 3 (начало) - проверка совпадения всех символов по диагонали (обратной) массива.
def func_win_diog_reverse(list_):
    list_reverse = [] # задаем переменную list,
    # сюда будем сохранять развернутый справа-налево массив.
    for row in list_: # цикл разворота массива справа-налево (каждую строку)
        list_reverse.append(list(reversed(row))) # - build-in функция reversed() возвращает итератор,
        # поэтому ее нужно обернуть еще в list.

    func_win_diog(list_reverse) # - далее вызов ПРОВЕРКИ 2 (победа по диагонали) - слева-направо, сверху-вниз.
# <<<<< ПРОВЕРКА 3 (конец) ГОТОВО!
# --------------------------------------------------------------------------

# >>>>> ПРОВЕРКА 4 (начало) - совпадения всех символов по столбцу массива.

def func_win_column(list_):
    counter_simbol_x = 0
    counter_simbol_o = 0
    simbol_x, simbol_o = 'х', 'о'
    for index_column in range(counter_column): # итерируем кол-во раз равное кол-ву столбцов (counter_column)
        for index_row in range(counter_row): # итерируем кол-во раз равное кол-ву строк (counter_column)
            if list_[index_row][index_column] == simbol_x: # проходимся по элементам 1го столбца, если символ 'x', то счетчик +1
                counter_simbol_x += 1
            if counter_simbol_x == counter_row: # если кол-во символов 'x' равно кол-ву строк - то победа.
                print('---------------------------------------')
                print('Победил Игрок 1. Символы совпали по столбцу.')
                return True  # - нужно для условия для цикла While (см. БЛОК 4. КОНТРОЛЕР).

            elif list_[index_row][index_column] == simbol_o: # проходимся по элементам 1го столбца, если символ 'o', то счетчик +1
                counter_simbol_o += 1
            if counter_simbol_o == counter_row: # если кол-во символов 'o' равно кол-ву строк - то победа.
                print('---------------------------------------')
                print('Победил Игрок 2.Символы совпали по столбцу.')
                return True  # - нужно для условия для цикла While (см. БЛОК 4. КОНТРОЛЕР).
        counter_simbol_x = 0 # Если в столбце не совпали все символы "x", обнуляем счетчик "x".
        counter_simbol_o = 0 # Если в столбце не совпали все символы "o", обнуляем счетчик "o".
# <<<<< ПРОВЕРКА 4 (конец). ГОТОВО!
# --------------------------------------------------------------------------

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# >>>>> БЛОК 2 (начало). Считаем количество ходов и печатаем сообщение о количестве ходов.
# Считаем соличество строк и столбцов в массиве.
counter_motion = 0
counter_row = len(gb)
counter_column = 0
for i in gb:
    pluser = i.count("-") # - расчет ходов по поиску поля "-"
    counter_motion += pluser # - суммируем к счетчик ходов.
    if len(i) >= counter_column and len(gb) == counter_row: # если длина списка в массиве и равно количеству строк
        # (чтобы матрица была квадратной), то
        counter_column = len(i) # ... перезаписываем значение в переменную counter_column
    else:
        print('Матрица не является квадратной. Стоп игра!')
        break

print(f'Всего в игре: {counter_motion} ходов.')
print('---------------------------------------')
# <<<<< БЛОК 2. (конец). ГОТОВО!

# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# >>>>> БЛОК 3 (начало). Выводим инфо о том, чей сейчас ход.
# Функция вставки символа в игровое поле.

def check_add_row_id(): # - защита ввода индекса строки отличного от цифры и попадание цифры в диапазон строки.
    try:
        add_row = int(input(f'Введите порядковый номер строки, от 1 до {counter_row}, для ввода символа:'))-1
        if add_row not in range(counter_row):
            raise IndexError
    except (ValueError, IndexError):
        print('Ошибка ввода.')
        result_1 = check_add_row_id()  # - запускаем опять функцию вводы строки.
        return result_1
    else:
        return add_row

def check_add_column_id(): # - защита ввода индекса столбца отличного от цифры и попадание цифры в диапазон столбца.
    try:
        add_column = int(input(f'Введите порядковый номер стобца, от 1 до {counter_column}, для ввода символа:')) - 1
        if add_column not in range(counter_column):
            raise IndexError
    except (ValueError, IndexError):
        print('Ошибка ввода.')
        result_2 = check_add_column_id()  # - запускаем опять функцию вводы строки.
        return result_2
    else:
        return add_column

def add_simbol(simbol):
    add_row = check_add_row_id()
    add_column = check_add_column_id()
    if [add_row, add_column] in previous_motion:  # здесь проверка на заполнение в пустое поле.
        print('Заполняемое поле не является свободным. Введите порядковый номер строки и столбца заново.')

    else:
        previous_motion.append([add_row, add_column])
        list_from_row = gb[add_row]
        gb[add_row].pop(add_column)
        gb[add_row].insert(add_column, simbol)
        return True  # Если символ игрока заполняется в сводобное поле, то True. # Это далее пригодится в цикле while.

# <<<<< БЛОК 3. (конец). ГОТОВО!
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# >>>>> БЛОК 4. (начало). КОНТРОЛЕР. Переключает игроков, в зависисоти от общего количества ходов - по очереди.

n = counter_motion # Передаем общее кол-во ходов и игре (из БЛОКА 2).
counter = n # Счетчик оставшихся ходов.

previous_motion = [] # Сбор инфо о ранее введенных ходах игроков.
# Для последующего контроля ввода в пустое поле.

while n >= 0: # Основной цикл. Работает, пока не закончятся ходы.

    if counter > 0 and counter % 2 > 0: # Если кол-во ходов нечетное,
        # то начинает ходить Игрок 1. Далее переключение по очереди.
        print('Ход Игрока 1. Игрок ходит крестиками = x.')
        simbol = 'х'
# Тут может замена функции будет. Разбитие на 2 функции.

        result = add_simbol(simbol) # Передача True из БЛОКА 3, если символ вводился в пустое поле.
        if result:
            print('---------------------------------------')
            current_gboard(gb) # Запускаем функцию из БЛОКА 1 - обновление текущего поля игры, его вывод.
            if func_win_line(gb) or func_win_diog(gb) or func_win_diog_reverse(gb) or func_win_column(gb): # Условия проверки выигрыша игроков.
                # Запускаем функцию из БЛОКА ПРОВЕРОК.
                print('Игра закончилась.')
                print('---------------------------------------')
                break


            print(f'Осталось: {counter - 1} ходов, из {n}.')
            print('---------------------------------------')
            counter -= 1 # убираем один ход.

        else:
            print('---------------------------------------')
            print(f'Осталось: {counter} ходов, из {n}.')
            current_gboard(gb)
            print('---------------------------------------')
    elif counter > 0 and counter % 2 == 0:
        print('Ход Игрока 2. Игрок ходит ноликами = о.')
        simbol = 'о'

        result = add_simbol(simbol) #
        if result:
            print('---------------------------------------')
            current_gboard(gb)
            if func_win_line(gb) or func_win_diog(gb) or func_win_diog_reverse(gb) or func_win_column(gb) or ((counter-1) == 0):# Условия проверки выигрыша игроков.
                # Запускаем функцию из БЛОКА ПРОВЕРОК.
                print(f'Игра закончилась.')
                print('---------------------------------------')
                break


            print(f'Осталось: {counter - 1} ходов, из {n}.')
            print('---------------------------------------')
            counter -= 1  # убираем один ход.

        else:
            print('---------------------------------------')
            print(f'Осталось: {counter} ходов, из {n}.')
            current_gboard(gb)
            print('---------------------------------------')

    else:
        print('Игра закончена. Никто не выграл. Ничья.')
        break
# <<<<< БЛОК 4. (конец). ГОТОВО!
# \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


